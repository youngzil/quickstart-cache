1、构建的一个分布式代理，如Envoy
2、将所有流量代理到旧实例，如Envoy 负责侦听 Redis 请求的特定端口，它直接将请求（读和写）转发给实际的旧 Redis 实例。
3、将写入镜像到新集群，写入流量代理到新实例，将其镜像或双写到新的集群化 Redis。这样，任何新的写入都可以同时写到旧的和新的 Redis 实例。

4、将内容完整地回填到新集群，旧实例数据同步到新的Redis实例，这两个实例应该完全同步了，任何错过的双写都应该被捕获了。
这一步是计算最密集的，需要扫描旧的 Redis 实例并将其所有内容复制到新实例。为了更有效率，我们使用了 RedisShake （一个来自阿里巴巴的优秀开源工具）
Redis-shake是一个用于在两个redis之间同步数据的工具，满足用户非常灵活的同步、迁移需求。

5、验证并切换，
为了确保这两个实例是同步的，我们运行 RedisFullCheck 工具，它经过几轮比较后可以区分旧实例和新实例之间存在差异的键，并将它们存储到 SQLite 数据库中。
一旦检查脚本结果没有问题，我们最后会再次更新 Envoy 侦听器配置，将所有的流量全部路由到新集群，并删除旧实例。






Redis-shake是一个用于在两个redis之间同步数据的工具，满足用户非常灵活的同步、迁移需求。


